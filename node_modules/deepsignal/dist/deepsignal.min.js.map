{"version":3,"file":"deepsignal.min.js","sources":["../core/src/index.ts","../src/index.ts"],"sourcesContent":["import { computed, signal, Signal } from \"@preact/signals-core\";\n\nconst proxyToSignals = new WeakMap();\nconst objToProxy = new WeakMap();\nconst arrayToArrayOfSignals = new WeakMap();\nconst ignore = new WeakSet();\nconst objToIterable = new WeakMap();\nconst rg = /^\\$/;\nconst descriptor = Object.getOwnPropertyDescriptor;\nlet peeking = false;\n\nexport const deepSignal = <T extends object>(obj: T): DeepSignal<T> => {\n\tif (!shouldProxy(obj)) throw new Error(\"This object can't be observed.\");\n\tif (!objToProxy.has(obj))\n\t\tobjToProxy.set(obj, createProxy(obj, objectHandlers) as DeepSignal<T>);\n\treturn objToProxy.get(obj);\n};\n\nexport const peek = <\n\tT extends DeepSignalObject<object>,\n\tK extends keyof RevertDeepSignalObject<T>\n>(\n\tobj: T,\n\tkey: K\n): RevertDeepSignal<RevertDeepSignalObject<T>[K]> => {\n\tpeeking = true;\n\tconst value = obj[key];\n\ttry {\n\t\tpeeking = false;\n\t} catch (e) {}\n\treturn value as RevertDeepSignal<RevertDeepSignalObject<T>[K]>;\n};\n\nconst isShallow = Symbol(\"shallow\");\nexport function shallow<T extends object>(obj: T): Shallow<T> {\n\tignore.add(obj);\n\treturn obj as Shallow<T>;\n}\n\nconst createProxy = (target: object, handlers: ProxyHandler<object>) => {\n\tconst proxy = new Proxy(target, handlers);\n\tignore.add(proxy);\n\treturn proxy;\n};\n\nconst throwOnMutation = () => {\n\tthrow new Error(\"Don't mutate the signals directly.\");\n};\n\nconst get =\n\t(isArrayOfSignals: boolean) =>\n\t(target: object, fullKey: string, receiver: object): unknown => {\n\t\tif (peeking) return Reflect.get(target, fullKey, receiver);\n\t\tlet returnSignal = isArrayOfSignals || fullKey[0] === \"$\";\n\t\tif (!isArrayOfSignals && returnSignal && Array.isArray(target)) {\n\t\t\tif (fullKey === \"$\") {\n\t\t\t\tif (!arrayToArrayOfSignals.has(target))\n\t\t\t\t\tarrayToArrayOfSignals.set(target, createProxy(target, arrayHandlers));\n\t\t\t\treturn arrayToArrayOfSignals.get(target);\n\t\t\t}\n\t\t\treturnSignal = fullKey === \"$length\";\n\t\t}\n\t\tif (!proxyToSignals.has(receiver)) proxyToSignals.set(receiver, new Map());\n\t\tconst signals = proxyToSignals.get(receiver);\n\t\tconst key = returnSignal ? fullKey.replace(rg, \"\") : fullKey;\n\t\tif (\n\t\t\t!signals.has(key) &&\n\t\t\ttypeof descriptor(target, key)?.get === \"function\"\n\t\t) {\n\t\t\tsignals.set(\n\t\t\t\tkey,\n\t\t\t\tcomputed(() => Reflect.get(target, key, receiver))\n\t\t\t);\n\t\t} else {\n\t\t\tlet value = Reflect.get(target, key, receiver);\n\t\t\tif (returnSignal && typeof value === \"function\") return;\n\t\t\tif (typeof key === \"symbol\" && wellKnownSymbols.has(key)) return value;\n\t\t\tif (!signals.has(key)) {\n\t\t\t\tif (shouldProxy(value)) {\n\t\t\t\t\tif (!objToProxy.has(value))\n\t\t\t\t\t\tobjToProxy.set(value, createProxy(value, objectHandlers));\n\t\t\t\t\tvalue = objToProxy.get(value);\n\t\t\t\t}\n\t\t\t\tsignals.set(key, signal(value));\n\t\t\t}\n\t\t}\n\t\treturn returnSignal ? signals.get(key) : signals.get(key).value;\n\t};\n\nconst objectHandlers = {\n\tget: get(false),\n\tset(target: object, fullKey: string, val: any, receiver: object): boolean {\n\t\tif (typeof descriptor(target, fullKey)?.set === \"function\")\n\t\t\treturn Reflect.set(target, fullKey, val, receiver);\n\t\tif (!proxyToSignals.has(receiver)) proxyToSignals.set(receiver, new Map());\n\t\tconst signals = proxyToSignals.get(receiver);\n\t\tif (fullKey[0] === \"$\") {\n\t\t\tif (!(val instanceof Signal)) throwOnMutation();\n\t\t\tconst key = fullKey.replace(rg, \"\");\n\t\t\tsignals.set(key, val);\n\t\t\treturn Reflect.set(target, key, val.peek(), receiver);\n\t\t} else {\n\t\t\tlet internal = val;\n\t\t\tif (shouldProxy(val)) {\n\t\t\t\tif (!objToProxy.has(val))\n\t\t\t\t\tobjToProxy.set(val, createProxy(val, objectHandlers));\n\t\t\t\tinternal = objToProxy.get(val);\n\t\t\t}\n\t\t\tconst isNew = !(fullKey in target);\n\t\t\tconst result = Reflect.set(target, fullKey, val, receiver);\n\t\t\tif (!signals.has(fullKey)) signals.set(fullKey, signal(internal));\n\t\t\telse signals.get(fullKey).value = internal;\n\t\t\tif (isNew && objToIterable.has(target)) objToIterable.get(target).value++;\n\t\t\tif (Array.isArray(target) && signals.has(\"length\"))\n\t\t\t\tsignals.get(\"length\").value = target.length;\n\t\t\treturn result;\n\t\t}\n\t},\n\tdeleteProperty(target: object, key: string): boolean {\n\t\tif (key[0] === \"$\") throwOnMutation();\n\t\tconst signals = proxyToSignals.get(objToProxy.get(target));\n\t\tconst result = Reflect.deleteProperty(target, key);\n\t\tif (signals && signals.has(key)) signals.get(key).value = undefined;\n\t\tobjToIterable.has(target) && objToIterable.get(target).value++;\n\t\treturn result;\n\t},\n\townKeys(target: object): (string | symbol)[] {\n\t\tif (!objToIterable.has(target)) objToIterable.set(target, signal(0));\n\t\t(objToIterable as any)._ = objToIterable.get(target).value;\n\t\treturn Reflect.ownKeys(target);\n\t},\n};\n\nconst arrayHandlers = {\n\tget: get(true),\n\tset: throwOnMutation,\n\tdeleteProperty: throwOnMutation,\n};\n\nconst wellKnownSymbols = new Set(\n\tObject.getOwnPropertyNames(Symbol)\n\t\t.map(key => Symbol[key as WellKnownSymbols])\n\t\t.filter(value => typeof value === \"symbol\")\n);\nconst supported = new Set([Object, Array]);\nconst shouldProxy = (val: any): boolean => {\n\tif (typeof val !== \"object\" || val === null) return false;\n\treturn supported.has(val.constructor) && !ignore.has(val);\n};\n\n/** TYPES **/\n\nexport type DeepSignal<T> = T extends Function\n\t? T\n\t: T extends { [isShallow]: true }\n\t? T\n\t: T extends Array<unknown>\n\t? DeepSignalArray<T>\n\t: T extends object\n\t? DeepSignalObject<T>\n\t: T;\n\ntype DeepSignalObject<T extends object> = {\n\t[P in keyof T & string as `$${P}`]?: T[P] extends Function\n\t\t? never\n\t\t: Signal<T[P]>;\n} & {\n\t[P in keyof T]: DeepSignal<T[P]>;\n};\n\n/** @ts-expect-error **/\ninterface DeepArray<T> extends Array<T> {\n\tmap: <U>(\n\t\tcallbackfn: (\n\t\t\tvalue: DeepSignal<T>,\n\t\t\tindex: number,\n\t\t\tarray: DeepSignalArray<T[]>\n\t\t) => U,\n\t\tthisArg?: any\n\t) => U[];\n\tforEach: (\n\t\tcallbackfn: (\n\t\t\tvalue: DeepSignal<T>,\n\t\t\tindex: number,\n\t\t\tarray: DeepSignalArray<T[]>\n\t\t) => void,\n\t\tthisArg?: any\n\t) => void;\n\tconcat(...items: ConcatArray<T>[]): DeepSignalArray<T[]>;\n\tconcat(...items: (T | ConcatArray<T>)[]): DeepSignalArray<T[]>;\n\treverse(): DeepSignalArray<T[]>;\n\tshift(): DeepSignal<T> | undefined;\n\tslice(start?: number, end?: number): DeepSignalArray<T[]>;\n\tsplice(start: number, deleteCount?: number): DeepSignalArray<T[]>;\n\tsplice(\n\t\tstart: number,\n\t\tdeleteCount: number,\n\t\t...items: T[]\n\t): DeepSignalArray<T[]>;\n\tfilter<S extends T>(\n\t\tpredicate: (\n\t\t\tvalue: DeepSignal<T>,\n\t\t\tindex: number,\n\t\t\tarray: DeepSignalArray<T[]>\n\t\t) => value is DeepSignal<S>,\n\t\tthisArg?: any\n\t): DeepSignalArray<S[]>;\n\tfilter(\n\t\tpredicate: (\n\t\t\tvalue: DeepSignal<T>,\n\t\t\tindex: number,\n\t\t\tarray: DeepSignalArray<T[]>\n\t\t) => unknown,\n\t\tthisArg?: any\n\t): DeepSignalArray<T[]>;\n\treduce(\n\t\tcallbackfn: (\n\t\t\tpreviousValue: DeepSignal<T>,\n\t\t\tcurrentValue: DeepSignal<T>,\n\t\t\tcurrentIndex: number,\n\t\t\tarray: DeepSignalArray<T[]>\n\t\t) => T\n\t): DeepSignal<T>;\n\treduce(\n\t\tcallbackfn: (\n\t\t\tpreviousValue: DeepSignal<T>,\n\t\t\tcurrentValue: DeepSignal<T>,\n\t\t\tcurrentIndex: number,\n\t\t\tarray: DeepSignalArray<T[]>\n\t\t) => DeepSignal<T>,\n\t\tinitialValue: T\n\t): DeepSignal<T>;\n\treduce<U>(\n\t\tcallbackfn: (\n\t\t\tpreviousValue: U,\n\t\t\tcurrentValue: DeepSignal<T>,\n\t\t\tcurrentIndex: number,\n\t\t\tarray: DeepSignalArray<T[]>\n\t\t) => U,\n\t\tinitialValue: U\n\t): U;\n\treduceRight(\n\t\tcallbackfn: (\n\t\t\tpreviousValue: DeepSignal<T>,\n\t\t\tcurrentValue: DeepSignal<T>,\n\t\t\tcurrentIndex: number,\n\t\t\tarray: DeepSignalArray<T[]>\n\t\t) => T\n\t): DeepSignal<T>;\n\treduceRight(\n\t\tcallbackfn: (\n\t\t\tpreviousValue: DeepSignal<T>,\n\t\t\tcurrentValue: DeepSignal<T>,\n\t\t\tcurrentIndex: number,\n\t\t\tarray: DeepSignalArray<T[]>\n\t\t) => DeepSignal<T>,\n\t\tinitialValue: T\n\t): DeepSignal<T>;\n\treduceRight<U>(\n\t\tcallbackfn: (\n\t\t\tpreviousValue: U,\n\t\t\tcurrentValue: DeepSignal<T>,\n\t\t\tcurrentIndex: number,\n\t\t\tarray: DeepSignalArray<T[]>\n\t\t) => U,\n\t\tinitialValue: U\n\t): U;\n}\ntype ArrayType<T> = T extends Array<infer I> ? I : T;\ntype DeepSignalArray<T> = DeepArray<ArrayType<T>> & {\n\t[key: number]: DeepSignal<ArrayType<T>>;\n\t$?: { [key: number]: Signal<ArrayType<T>> };\n\t$length?: Signal<number>;\n};\n\nexport type Shallow<T extends object> = T & { [isShallow]: true };\n\nexport declare const useDeepSignal: <T extends object>(obj: T) => DeepSignal<T>;\n\ntype FilterSignals<K> = K extends `$${infer P}` ? never : K;\ntype RevertDeepSignalObject<T> = Pick<T, FilterSignals<keyof T>>;\ntype RevertDeepSignalArray<T> = Omit<T, \"$\" | \"$length\">;\n\nexport type RevertDeepSignal<T> = T extends Array<unknown>\n\t? RevertDeepSignalArray<T>\n\t: T extends object\n\t? RevertDeepSignalObject<T>\n\t: T;\n\ntype WellKnownSymbols =\n\t| \"asyncIterator\"\n\t| \"hasInstance\"\n\t| \"isConcatSpreadable\"\n\t| \"iterator\"\n\t| \"match\"\n\t| \"matchAll\"\n\t| \"replace\"\n\t| \"search\"\n\t| \"species\"\n\t| \"split\"\n\t| \"toPrimitive\"\n\t| \"toStringTag\"\n\t| \"unscopables\";\n","import \"@preact/signals\";\nimport { useMemo } from \"preact/hooks\";\nimport { deepSignal, type DeepSignal } from \"../core/src\";\n\nexport const useDeepSignal = <T extends object>(obj: T): DeepSignal<T> => {\n\treturn useMemo(() => deepSignal(obj), []);\n};\n\nexport * from \"../core/src\";\n"],"names":["g","f","exports","module","require","define","amd","globalThis","self","deepsignal","hooks","signalsCore","this","signals","proxyToSignals","WeakMap","objToProxy","arrayToArrayOfSignals","ignore","WeakSet","objToIterable","rg","descriptor","Object","getOwnPropertyDescriptor","peeking","deepSignal","obj","shouldProxy","Error","has","set","createProxy","objectHandlers","get","target","handlers","proxy","Proxy","add","throwOnMutation","isArrayOfSignals","fullKey","receiver","_descriptor","Reflect","returnSignal","Array","isArray","arrayHandlers","Map","key","replace","value","wellKnownSymbols","signal","computed","val","_descriptor2","Signal","peek","internal","isNew","result","length","deleteProperty","undefined","ownKeys","_","Set","getOwnPropertyNames","Symbol","map","filter","supported","constructor","e","shallow","useDeepSignal","useMemo"],"mappings":"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"}